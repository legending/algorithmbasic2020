并查集
1)有若干个样本a、b、c、d…类型假设是V
2)在并查集中一开始认为每个样本都在单独的集合里3)用户可以在任何时候调用如下两个方法︰
boolean isSameSet(V x, v y):查询样本x和样本y是否属于一个集合
void union(V x,V y):把x和y各自所在集合的所有样本合并成一个集合
4) isSameSet和union方法的代价越低越好

并查集
1）每个节点都有一条往上指的指针
2)节点a往上找到的头节点,叫做a所在集合的代表节点
3）查询x和y是否属于同一个集合，就是看看找到的代表节点是不是一个
4）把x和y各自所在集合的所有点合并成一个集合，只需要小集合的代表点挂在大集合的代表点的下方即可

图
1)l由点的集合和边的集合构成
2）虽然存在有向图和无向图的概念，但实际上都可以用有向图来表达
3)边上可能带有权值

图结构的表达
1)邻接表法
2)邻接矩阵法
3）除此之外还有其他众多的方式

图的面试题如何搞定
图的算法都不算难，只不过coding的代价比较高
1）先用自己最熟练的方式，实现图结构的表达
2）在自己熟悉的结构上，实现所有常用的图算法作为模板
3）把面试题提供的图结构转化为自己熟悉的图结构，再调用模板或改写即可

图的宽度优先&深度优先遍历
宽度优先遍历
1. 利用队列实现
2．从源节点开始依次按照宽度进队列．然后弹出
3. 每弹出一个点．把该节点所有没有进过队列的邻接点放入队列
4．直到队列变空
深度优先遍历
1．利用栈实现
2．从源节点开始把节点按照深度放入栈. 然后弹出
3. 每弹出一个点.把该节点下一个没有进过栈的邻接点放入栈
4．直到栈变空

最小生成树算法之Kruskal
1)总是从权值最小的边开始考虑，依次考察权值依次变大的边
2）当前的边要么进入最小生成树的集合，要么丢弃
3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边
4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边
5)考察完所有边之后，最小生成树的集合也得到了